# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T07:57:09+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBasic
from fastapi import Path, Query, UploadFile
from pydantic import conint

from models import (
    Access,
    Accounts,
    App,
    AppPages,
    AppVersion,
    Cards,
    Developer,
    DeveloperAccount,
    DeveloperAccountPages,
    DeveloperPages,
    DeveloperToken,
    Event,
    File,
    FileDownload,
    Market,
    ModifiedBy,
    Ownership,
    OwnershipPages,
    Period,
    Review,
    ReviewPages,
    SearchPages,
    StatsSeriesPeriodFieldsGetResponse,
    Status1,
    Total,
    Transaction,
    TransactionPages,
    User,
    UserAccount,
    UserAccountPages,
    UserPages,
    VersionPages,
)

app = MCPProxy(
    title='OpenChannel Market API',
    version='2.0.24',
    servers=[{'url': 'https://market.openchannel.io/v2'}],
)


@app.get(
    '/apps',
    description=""" - Results are paginated and the default is value is 1000 if no limit is provided
- If no query is specified, returns all APPROVED or SUSPENDED apps within the marketplace
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_apps(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
    user_id: Optional[str] = Query(None, alias='userId'),
    is_owner: Optional[bool] = Query(None, alias='isOwner'),
):
    """
    Returns a paginated list of APPROVED or SUSPENDED apps
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps',
    description=""" - This method is called on behalf of a developer.
- Price is required if the model is 'single' or 'recurring'
- Returns the newly created app
 """,
    tags=['app_management', 'developer_account_crud'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_apps(
    developer_id: str = Query(..., alias='developerId'),
    name: str = ...,
    type: Optional[str] = None,
    model: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
    attributes: Optional[str] = None,
    restrict: Optional[str] = None,
    allow: Optional[str] = None,
    access: Optional[str] = None,
):
    """
    Adds a new app for this developer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/bySafeName/{safeName}',
    description=""" - A 'view' event is recorded when trackViews is set to true
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_apps_by_safe_name__safe_name(
    safe_name: str = Path(..., alias='safeName'),
    user_id: Optional[str] = Query(None, alias='userId'),
    track_views: Optional[bool] = Query(None, alias='trackViews'),
):
    """
    Returns a single APPROVED or SUSPENDED app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/textSearch',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_apps_text_search(
    query: Optional[str] = None,
    text: str = ...,
    fields: str = ...,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
    user_id: Optional[str] = Query(None, alias='userId'),
    is_owned: Optional[bool] = Query(None, alias='isOwned'),
):
    """
    Searches through the text of fields to find APPROVED or SUSPENDED apps
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/versions',
    description=""" - Results are paginated when limit is set, otherwise all results are returned
- If no query is specified, returns all AppVersions within the marketplace
- Only returns AppVersions owned by this developer
 """,
    tags=['app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_apps_versions(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
    developer_id: Optional[str] = Query(None, alias='developerId'),
):
    """
    Returns a paginated list of AppVersions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}',
    description=""" - This method is called on behalf of a developer.
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_apps__app_id(
    app_id: str = Path(..., alias='appId'),
    developer_id: str = Query(..., alias='developerId'),
):
    """
    Removes app and all versions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}',
    description=""" - A 'view' event is recorded when trackViews is set to true
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_apps__app_id(
    app_id: str = Path(..., alias='appId'),
    user_id: Optional[str] = Query(None, alias='userId'),
    track_views: Optional[bool] = Query(None, alias='trackViews'),
):
    """
    Returns a single APPROVED or SUSPENDED app
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/live',
    description=""" - This method is called on behalf of a developer.
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_apps__app_id_live(
    app_id: str = Path(..., alias='appId'),
    developer_id: str = Query(..., alias='developerId'),
    version: str = ...,
):
    """
    Change the live app to another, previously approved version
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/publish',
    description=""" - This method is called on behalf of a developer. 
- Only effects the current working version of the app.
 """,
    tags=['app_management', 'marketplace_information_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_apps__app_id_publish(
    app_id: str = Path(..., alias='appId'),
    developer_id: str = Query(..., alias='developerId'),
    version: int = ...,
    auto_approve: Optional[bool] = Query(None, alias='autoApprove'),
):
    """
    Publishes the current working version of the app to the marketplace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/apps/{appId}/versions/{version}',
    description=""" - This method is called on behalf of a developer.
 """,
    tags=['app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_apps__app_id_versions__version(
    app_id: str = Path(..., alias='appId'),
    version: str = ...,
    developer_id: str = Query(..., alias='developerId'),
):
    """
    Removes AppVersion
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/apps/{appId}/versions/{version}',
    description=""" - Only returns AppVersions owned by this developer
 """,
    tags=['app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_apps__app_id_versions__version(
    app_id: str = Path(..., alias='appId'),
    version: int = ...,
    developer_id: Optional[str] = Query(None, alias='developerId'),
):
    """
    Returns a single AppVersion
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/apps/{appId}/versions/{version}',
    description=""" - This method is called on behalf of a developer.
- Price and is required if the model is 'single' or 'recurring'
- Returns the newly updated app
- This endpoint updates only the fields provided in the request (relative update). In contrast, the POST version of this method replaces the entire object to match the request (absolute update). 
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def patch_apps__app_id_versions__version(
    app_id: str = Path(..., alias='appId'),
    version: str = ...,
    developer_id: str = Query(..., alias='developerId'),
    name: Optional[str] = None,
    type: Optional[str] = None,
    model: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
    attributes: Optional[str] = None,
    restrict: Optional[str] = None,
    allow: Optional[str] = None,
    access: Optional[str] = None,
    approval_required: Optional[str] = Query(None, alias='approvalRequired'),
):
    """
    Updates the app fields or creates a new version
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/versions/{version}',
    description=""" - This method is called on behalf of a developer.
- Price and is required if the model is 'single' or 'recurring'
- Returns the newly updated app
- This endpoint replaces the entire object to match the request (absolute update). In contrast, the PATCH version of this endpoint updates only the fields provided in the request (relative update).
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_apps__app_id_versions__version(
    app_id: str = Path(..., alias='appId'),
    version: str = ...,
    developer_id: str = Query(..., alias='developerId'),
    name: Optional[str] = None,
    type: Optional[str] = None,
    model: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
    attributes: Optional[str] = None,
    restrict: Optional[str] = None,
    allow: Optional[str] = None,
    access: Optional[str] = None,
    approval_required: Optional[str] = Query(None, alias='approvalRequired'),
):
    """
    Updates the app or creates a new version
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/apps/{appId}/versions/{version}/status',
    description=""" Only certain status changes are allowed. For instance, a developer is only able to suspend and unsuspend their app (which must already be approved). See here for a state change diagram of allowed status changes for administrators: https://support.openchannel.io/documentation/api/#415-apps-status-change
 """,
    tags=['app_management', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_apps__app_id_versions__version_status(
    app_id: str = Path(..., alias='appId'),
    version: int = ...,
    developer_id: Optional[str] = Query(None, alias='developerId'),
    status: Optional[Status1] = None,
    modified_by: Optional[ModifiedBy] = Query('administrator', alias='modifiedBy'),
    reason: Optional[str] = None,
):
    """
    Allows a developer or administrator to change the status of apps
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/custom-gateway/payment/{ownershipId}',
    description=""" - Results are returned for the market provided within the basic authentication credentials 
- Payments must be enabled and 'Custom' must be selected as the gateway in order to use this API endpoint
 """,
    tags=['payment_transaction_processing', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_custom_gateway_payment__ownership_id(
    ownership_id: str = Path(..., alias='ownershipId'),
    amount: int = ...,
    date: Optional[int] = None,
    fee_amount: Optional[int] = Query(None, alias='feeAmount'),
    marketplace_amount: Optional[int] = Query(None, alias='marketplaceAmount'),
    developer_amount: Optional[int] = Query(None, alias='developerAmount'),
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Adds a payment for an app on behalf of a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/custom-gateway/refund/{ownershipId}',
    description=""" - Results are returned for the market provided within the basic authentication credentials
- Payments must be enabled and 'Custom' must be selected as the gateway in order to use this API endpoint
 """,
    tags=['payment_transaction_processing', 'app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_custom_gateway_refund__ownership_id(
    ownership_id: str = Path(..., alias='ownershipId'),
    amount: int = ...,
    date: Optional[int] = None,
    fee_amount: Optional[int] = Query(None, alias='feeAmount'),
    marketplace_amount: Optional[int] = Query(None, alias='marketplaceAmount'),
    developer_amount: Optional[int] = Query(None, alias='developerAmount'),
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Fully or partially refund payment for an app on behalf of a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/developerAccounts',
    description=""" - Results are paginated and the default is value is 1000 if no limit is provided
 """,
    tags=['developer_account_crud'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_developer_accounts(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
):
    """
    Returns a paginated list of developerAccounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/developerAccounts/{developerAccountId}',
    tags=['developer_account_crud'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_developer_accounts__developer_account_id(
    developer_account_id: str = Path(..., alias='developerAccountId')
):
    """
    Removes the developer account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/developerAccounts/{developerAccountId}',
    tags=['developer_account_crud'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_developer_accounts__developer_account_id(
    developer_account_id: str = Path(..., alias='developerAccountId')
):
    """
    Returns a single developer account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/developerAccounts/{developerAccountId}',
    tags=['developer_account_crud', 'developer_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def patch_developer_accounts__developer_account_id(
    developer_account_id: str = Path(..., alias='developerAccountId'),
    developer_id: str = Query(..., alias='developerId'),
    email: Optional[str] = None,
    name: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates the developer account fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/developerAccounts/{developerAccountId}',
    tags=['developer_account_crud', 'developer_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_developer_accounts__developer_account_id(
    developer_account_id: str = Path(..., alias='developerAccountId'),
    developer_id: str = Query(..., alias='developerId'),
    email: Optional[str] = None,
    name: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates the developer account or adds the developer account if it doesn't exist
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/developers',
    description=""" - Results are paginated and the default is value is 100 if no limit is provided
 """,
    tags=['developer_account_crud', 'developer_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_developers(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
):
    """
    Returns a paginated list of developers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/developers/{developerId}',
    tags=['developer_account_crud', 'developer_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_developers__developer_id(developer_id: str = Path(..., alias='developerId')):
    """
    Removes a single developer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/developers/{developerId}',
    tags=['developer_account_crud', 'developer_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_developers__developer_id(developer_id: str = Path(..., alias='developerId')):
    """
    Returns a single developer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/developers/{developerId}',
    tags=['developer_account_crud', 'developer_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def patch_developers__developer_id(
    developer_id: str = Path(..., alias='developerId'),
    type: Optional[str] = None,
    email: Optional[str] = None,
    username: Optional[str] = None,
    name: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates the developer fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/developers/{developerId}',
    tags=['developer_account_crud', 'developer_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_developers__developer_id(
    developer_id: str = Path(..., alias='developerId'),
    type: Optional[str] = None,
    email: Optional[str] = None,
    username: Optional[str] = None,
    name: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates the developer record or adds the developer if it doesn't exist
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events/{eventId}',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['event_info_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_events__event_id(event_id: str = Path(..., alias='eventId')):
    """
    Returns an event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files',
    tags=['file_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_files(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
):
    """
    Returns a paginated list of files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files',
    description=""" - WARNING: File URLs or fileIds must be stored somewhere within the customData field for an app, review, developer or user. Unused files will be removed after a few days. 
- This method is called on behalf of a developer.
 """,
    tags=['file_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_files(
    is_private: Optional[bool] = Query(None, alias='isPrivate'),
    hash: Optional[str] = None,
    file: UploadFile = ...,
):
    """
    Uploads a file.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/byIdOrUrl',
    tags=['file_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_files_by_id_or_url(file_id_or_url: str = Query(..., alias='fileIdOrUrl')):
    """
    Get the details for a file.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/download',
    tags=['file_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_files_download(
    file_id: str = Query(..., alias='fileId'),
    valid_seconds: Optional[int] = Query(None, alias='validSeconds'),
):
    """
    A signed URL for downloading a private file can be returned by providing the fileId.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files/url',
    description=""" - WARNING: File URLs or fileIds must be stored somewhere within the customData field for an app, review, developer or user. Unused files will be removed after a few days.
- This method is called on behalf of a developer.
 """,
    tags=['file_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_files_url(
    url: str, is_private: Optional[bool] = Query(None, alias='isPrivate')
):
    """
    Uploads a file from a URL
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/markets/this',
    tags=['marketplace_information_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_markets_this():
    """
    Returns the current marketplace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ownership',
    description="""  - Results are returned for the market provided within the basic authentication credentials  """,
    tags=['app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_ownership(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
):
    """
    Returns a paginated list of app licenses
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ownership/install',
    description="""  - This method is called on behalf of a user - This method requires either a modelId from the app or a custom model - User data and statistics are recorded when this method is called  """,
    tags=['app_ownership_management', 'app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_ownership_install(
    app_id: str = Query(..., alias='appId'),
    user_id: str = Query(..., alias='userId'),
    model_id: Optional[str] = Query(None, alias='modelId'),
    model: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Aquires an app license for a user (installs app)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ownership/uninstall/{ownershipId}',
    description="""  - This method is called on behalf of a user - User data and statistics are recorded when this method is called  """,
    tags=['app_ownership_management', 'app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_ownership_uninstall__ownership_id(
    ownership_id: str = Path(..., alias='ownershipId'),
    user_id: str = Query(..., alias='userId'),
    cancel_ownership: Optional[bool] = Query(None, alias='cancelOwnership'),
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Uninstalls a license for a particular user and app (uninstalls app)
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ownership/{ownershipId}',
    description="""  - Results are returned for the market provided within the basic authentication credentials  """,
    tags=['app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_ownership__ownership_id(ownership_id: str = Path(..., alias='ownershipId')):
    """
    Returns an ownership record
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/ownership/{ownershipId}',
    description="""  - Results are returned for the market provided within the basic authentication credentials  """,
    tags=['app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def patch_ownership__ownership_id(
    ownership_id: str = Path(..., alias='ownershipId'),
    custom_data: Optional[str] = Query(None, alias='customData'),
    expires: Optional[int] = None,
):
    """
    Updates ownership fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ownership/{ownershipId}',
    description="""  - Results are returned for the market provided within the basic authentication credentials  """,
    tags=['app_ownership_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_ownership__ownership_id(
    ownership_id: str = Path(..., alias='ownershipId'),
    custom_data: Optional[str] = Query(None, alias='customData'),
    expires: Optional[int] = None,
):
    """
    Updates an ownership record
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/permission/apps/{appId}',
    tags=['user_permission_management', 'app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_permission_apps__app_id(
    app_id: str = Path(..., alias='appId'), user_id: str = Query(..., alias='userId')
):
    """
    Removes permission that allows the app to access this user's data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/permission/apps/{appId}',
    tags=['user_permission_management', 'app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_permission_apps__app_id(
    app_id: str = Path(..., alias='appId'), user_id: str = Query(..., alias='userId')
):
    """
    Returns permission that allows the app to access this user's data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/permission/apps/{appId}',
    tags=['user_permission_management', 'app_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_permission_apps__app_id(
    app_id: str = Path(..., alias='appId'),
    user_id: str = Query(..., alias='userId'),
    date: Optional[int] = None,
    ip: Optional[str] = None,
):
    """
    Adds permission to allow the app to access this user's data
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reviews',
    description=""" - Results are paginated and the default is value is 100 if no limit is provided
 """,
    tags=['user_review_management', 'marketplace_information_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_reviews(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
):
    """
    Find reviews for a particular App and marketplace. Results are automatically paginated when limit is set
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reviews',
    description=""" - Only authenticated users are able to post reviews
- Returns the newly created review
 """,
    tags=['user_review_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_reviews(
    app_id: str = Query(..., alias='appId'),
    user_id: str = Query(..., alias='userId'),
    user_account_id: Optional[str] = Query(None, alias='userAccountId'),
    headline: str = ...,
    rating: conint(ge=0, le=500) = ...,
    description: str = ...,
    type: Optional[str] = None,
    must_own_app: Optional[bool] = Query(None, alias='mustOwnApp'),
    auto_approve: Optional[bool] = Query(None, alias='autoApprove'),
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Post a review from a User and returns the new post
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/reviews/{reviewId}',
    description=""" - Only the review author is able to remove their review
 """,
    tags=['user_review_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_reviews__review_id(
    review_id: str = Path(..., alias='reviewId'),
    user_id: str = Query(..., alias='userId'),
    user_account_id: Optional[str] = Query(None, alias='userAccountId'),
):
    """
    Remove a review
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/reviews/{reviewId}',
    tags=['user_review_management', 'marketplace_information_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_reviews__review_id(review_id: str = Path(..., alias='reviewId')):
    """
    Find a Review within a particular App and marketplace
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/reviews/{reviewId}',
    description=""" - Only the review author is able to update their review
- Returns the newly updated review
 """,
    tags=['user_review_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def patch_reviews__review_id(
    review_id: str = Path(..., alias='reviewId'),
    user_id: str = Query(..., alias='userId'),
    user_account_id: Optional[str] = Query(None, alias='userAccountId'),
    headline: Optional[str] = None,
    rating: Optional[conint(ge=0, le=500)] = None,
    description: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Update a review fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/reviews/{reviewId}',
    description=""" - Only the review author is able to update their review
- Returns the newly updated review
 """,
    tags=['user_review_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_reviews__review_id(
    review_id: str = Path(..., alias='reviewId'),
    user_id: str = Query(..., alias='userId'),
    user_account_id: str = Query(..., alias='userAccountId'),
    headline: str = ...,
    rating: conint(ge=0, le=500) = ...,
    description: str = ...,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Update a review from a User and returns the new post
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/stats/increment/{field}',
    description=""" increment a statistics field """,
    tags=['app_statistics_collection'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_stats_increment__field(
    field: str,
    app_id: str = Query(..., alias='appId'),
    user_id: Optional[str] = Query(None, alias='userId'),
    value: Optional[int] = None,
    date: Optional[int] = None,
):
    """
    Increments a statistics field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/series/{period}/{fields}',
    description=""" Return a timeseries nested array containing date and value. Example: [[1406520000000,2],[1406606400000,34],[1406692800000,245],...] """,
    tags=['app_statistics_collection'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_stats_series__period__fields(
    period: Period,
    fields: str = ...,
    start: Optional[int] = None,
    end: Optional[int] = None,
    query: Optional[str] = None,
):
    """
    Return a timeseries for a particular field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stats/total',
    tags=['event_info_management', 'app_statistics_collection'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_stats_total(
    fields: str,
    query: Optional[str] = None,
    start: Optional[int] = None,
    end: Optional[int] = None,
):
    """
    Returns the total number of events for a particular field.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stripe-gateway/developer/{developerId}/accounts',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['stripe_account_operations', 'developer_account_crud'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_stripe_gateway_developer__developer_id_accounts(
    developer_id: str = Path(..., alias='developerId')
):
    """
    Returns a developers connected Stripe accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/stripe-gateway/developer/{developerId}/accounts',
    description=""" - Results are returned for the market provided within the basic authentication credentials 
- The URL generated by this method is only valid for 48 hours.
 """,
    tags=['stripe_account_operations', 'developer_account_crud'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_stripe_gateway_developer__developer_id_accounts(
    developer_id: str = Path(..., alias='developerId'),
    redirect_url: str = Query(..., alias='redirectUrl'),
):
    """
    Generate a temporary URL to allow a developer to connect their Stripe account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/stripe-gateway/developer/{developerId}/accounts/{stripeId}',
    description=""" 
- Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['stripe_account_operations', 'developer_account_crud'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def disconnect_stripe_account_for_developer(
    developer_id: str = Path(..., alias='developerId'),
    stripe_id: str = Path(..., alias='stripeId'),
):
    """
    Disconnects a developer's Stripe account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/stripe-gateway/user/{userId}/cards',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['stripe_account_operations', 'user_account_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_stripe_gateway_user__user_id_cards(user_id: str = Path(..., alias='userId')):
    """
    Returns credit cards for this user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/stripe-gateway/user/{userId}/cards',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['payment_transaction_processing', 'stripe_account_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_stripe_gateway_user__user_id_cards(
    user_id: str = Path(..., alias='userId'),
    token: str = ...,
    is_default: Optional[bool] = Query(None, alias='isDefault'),
):
    """
    Adds credit card for this user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/stripe-gateway/user/{userId}/cards/{cardId}',
    tags=['stripe_account_operations', 'user_account_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_stripe_gateway_user__user_id_cards__card_id(
    user_id: str = Path(..., alias='userId'), card_id: str = Path(..., alias='cardId')
):
    """
    Removes a credit card for a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/stripe-gateway/user/{userId}/cards/{cardId}',
    description=""" 
- Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['stripe_account_operations', 'user_account_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_stripe_gateway_user__user_id_cards__card_id(
    user_id: str = Path(..., alias='userId'),
    card_id: str = Path(..., alias='cardId'),
    is_default: Optional[bool] = Query(None, alias='isDefault'),
    address_city: Optional[str] = None,
    address_country: Optional[str] = None,
    address_line1: Optional[str] = None,
    address_line2: Optional[str] = None,
    address_state: Optional[str] = None,
    address_zip: Optional[str] = None,
):
    """
    Updates a credit card for this user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions',
    description=""" - Results are paginated and the default is value is 100 if no limit is provided
 """,
    tags=['payment_transaction_processing', 'transaction_details_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_transactions(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
):
    """
    Returns a paginated list of transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/transactions/{transactionId}',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['payment_transaction_processing', 'transaction_details_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_transactions__transaction_id(
    transaction_id: str = Path(..., alias='transactionId')
):
    """
    Deleted a transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/{transactionId}',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['payment_transaction_processing', 'transaction_details_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_transactions__transaction_id(
    transaction_id: str = Path(..., alias='transactionId')
):
    """
    Returns a transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/transactions/{transactionId}',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['payment_transaction_processing', 'transaction_details_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_transactions__transaction_id(
    transaction_id: str = Path(..., alias='transactionId'),
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates a transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userAccounts',
    description=""" - Results are paginated and the default is value is 1000 if no limit is provided
 """,
    tags=['user_account_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_accounts(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
):
    """
    Returns a paginated list of userAccounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/userAccounts/{userAccountId}',
    tags=['user_account_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_user_accounts__user_account_id(
    user_account_id: str = Path(..., alias='userAccountId')
):
    """
    Removes the user account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/userAccounts/{userAccountId}',
    tags=['user_account_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_user_accounts__user_account_id(
    user_account_id: str = Path(..., alias='userAccountId')
):
    """
    Returns a single user account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/userAccounts/{userAccountId}',
    tags=['user_account_operations', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def patch_user_accounts__user_account_id(
    user_account_id: str = Path(..., alias='userAccountId'),
    user_id: str = Query(..., alias='userId'),
    email: Optional[str] = None,
    name: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates the user account fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/userAccounts/{userAccountId}',
    tags=['user_account_operations', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_user_accounts__user_account_id(
    user_account_id: str = Path(..., alias='userAccountId'),
    user_id: str = Query(..., alias='userId'),
    email: Optional[str] = None,
    name: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates the user account or adds the user account if it doesn't exist
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users',
    description=""" - Results are paginated and the default is value is 100 if no limit is provided
 """,
    tags=['user_account_operations', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_users(
    query: Optional[str] = None,
    sort: Optional[str] = None,
    page_number: Optional[int] = Query(None, alias='pageNumber'),
    limit: Optional[int] = None,
):
    """
    Returns a paginated list of users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/users/{userId}',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['user_account_operations'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def delete_users__user_id(user_id: str = Path(..., alias='userId')):
    """
    Removes a single user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/users/{userId}',
    description=""" - Results are returned for the market provided within the basic authentication credentials
 """,
    tags=['user_account_operations', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def get_users__user_id(user_id: str = Path(..., alias='userId')):
    """
    Return a single user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/users/{userId}',
    tags=['user_account_operations', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def patch_users__user_id(
    user_id: str = Path(..., alias='userId'),
    type: Optional[str] = None,
    email: Optional[str] = None,
    username: Optional[str] = None,
    name: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates user fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/users/{userId}',
    tags=['user_account_operations', 'user_profile_management'],
    security=[
        HTTPBasic(name="None"),
    ],
)
def post_users__user_id(
    user_id: str = Path(..., alias='userId'),
    type: Optional[str] = None,
    email: Optional[str] = None,
    username: Optional[str] = None,
    name: Optional[str] = None,
    custom_data: Optional[str] = Query(None, alias='customData'),
):
    """
    Updates a single user or adds the user if they don't exist
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
